<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
</head>
<body>
<div>
    Яндекс
    Контест
    Русский
    goro4@mail.ru

    Школа бэкенд-разработки 2021 (осень)
    7 сен 2021, 12:26:54
    старт:
    7 сен 2021, 12:26:54
    финиш:
    7 сен 2021, 18:26:54
    до финиша:
    05:55:40
    ...
    A. Состав заказа
    Ограничение времени 	2 секунды
    Ограничение памяти 	512.0 Мб
    Ввод 	стандартный ввод или input.txt
    Вывод 	стандартный вывод или output.txt

    Одной из важных частей онлайн-магазинов является обработка заказов. Заказ содержит в себе несколько товаров, каждый из которых приобретается в определенном количестве.

    Но состав заказа не является строго фиксированным с момента оформления до момента фактической отправки заказчику. Пользователь может передумать покупать какой-либо товар (весь или частично) или, наоборот, решить увеличить количество какого-либо товара в заказе перед отправкой. В итоге может получиться даже так, что заказ в итоге нет смысла отправлять, так как в нём не осталось товаров.

    Всё, что происходит с заказами в системе, фиксируется в формате событий "после изменения event_id в заказе order_id итоговое заказанное количество товара item_id равно count, а итоговое отмененное количество равно return_count". В итоге реальное количество товаров для отправки может быть вычислено как разница между count и return_count. Разница может получиться отрицательной - в рамках данной задачи это равносильно разнице, равной нулю (в причинах расхождения количеств в событии будет заниматься другой отдел).

    Также у товара в заказе есть статус - OKOK или CANCELCANCEL. Это независимая от количества товара информация, обозначающая возможность отправки товара в данном заказе - если товар находится в статусе CANCELCANCEL, то его не надо отправлять, сколько бы штук товара не требовалось. Важно отметить, что статус CANCELCANCEL может сменить на OKOK в дальнейшем - к примеру, на складе появилась новая партия товара.

    Вам требуется обработать список событий и вывести для каждого заказа итоговый список товаров для отправки. Для каждого товара необходимо учитывать только последнее событие (событие с максимальным значением event_id) среди событий, содержащих информацию о данном товаре. Если итоговый статус товара - CANCELCANCEL, то он не должен попасть в заказ. В заказ должны попасть только товары с ненулевым итоговым количеством для отправки. Выводить необходимо только заказы, в которых содержится хотя бы один товар для отправки.
    Формат ввода

    Входные данные представляют собой список событий в формате JSON.

    Гарантии по формату JSON:

    нет запятых после последнего элемента массива;
    все имена полей и строки обернуты в двойные кавычки.

    Гарантий по отступам и переводам строк нет - в примерах отступы и переводы строк используются для наглядности.

    Обозначим количество событий в списке через NN. Гарантируется, что 0≤N≤10000≤N≤1000.

    Каждое событие содержит следующую информацию (порядок полей не является фиксированным):

    event_id: идентификатор события.

    order_id: идентификатор заказа.

    item_id: идентификатор товара в заказе.

    count: Итоговое количество единиц товара в заказе, запрошенное к отправке.

    return_count: Итоговое количество единиц товара в заказе, отмененное к отправке.

    status: статус товара в заказе.

    Гарантируется, что идентификаторы и количества являются целыми числами (0≤(0≤ event_id, order_id, item_id ≤231−1≤231−1; 0≤0≤ count, return_count ≤109)≤109).

    Гарантируется, что статус представлен только строками OKOK и CANCELCANCEL.

    Гарантируется, что идентификаторы событий уникальны, но не гарантируется упорядоченность списка событий по возрастанию идентификаторов.
    Формат вывода

    Выведите в формате JSON список заказов для отправки.

    Выводить JSON допустимо без дополнительных отступов и переводов строк - в примерах отступы и переводы строк используются для наглядности.

    Имена полей необходимо выводить в двойных кавычках.

    Допустимо выводить запятую после последнего поля объекта или последнего элемента массива.

    Каждый заказ должен содержать следующую информацию:

    id: идентификатор заказа.
    items: список товаров в заказе.

    Каждый товар в заказе должен содержать следующую информацию:

    id: идентификатор товара.
    count: количество товара для отправки.

    Заказы и товары в рамках одного заказа можно выводить в любом порядке. Поля одной JSON-сущности так же можно выводить в любом порядке.

    Ответ не должен содержать:

    товары с нулевым количеством для отправки.
    товары с итоговым статусом CANCELCANCEL.
    заказы с пустым списком товаров.

    Пример 1
    Ввод
    Вывод

    [
    {
    "event_id": 1,
    "order_id": 1,
    "item_id": 1,
    "count": 1,
    "return_count": 0,
    "status": "OK"
    },
    {
    "event_id": 2,
    "order_id": 1,
    "item_id": 1,
    "count": 1,
    "return_count": 0,
    "status": "CANCEL"
    }
    ]



    []

    Пример 2
    Ввод
    Вывод

    [
    {
    "event_id": 2,
    "order_id": 1,
    "item_id": 1,
    "count": 2,
    "return_count": 1,
    "status": "OK"
    },
    {
    "event_id": 1,
    "order_id": 1,
    "item_id": 1,
    "count": 2,
    "return_count": 0,
    "status": "OK"
    }
    ]



    [
    {
    "id": 1,
    "items": [
    {
    "count": 1,
    "id": 1
    }
    ]
    }
    ]

    Пример 3
    Ввод
    Вывод

    [
    {
    "event_id": 2,
    "order_id": 2,
    "item_id": 1,
    "count": 3,
    "return_count": 1,
    "status": "OK"
    },
    {
    "event_id": 1,
    "order_id": 1,
    "item_id": 1,
    "count": 2,
    "return_count": 0,
    "status": "OK"
    },
    {
    "event_id": 3,
    "order_id": 3,
    "item_id": 1,
    "count": 2,
    "return_count": 2,
    "status": "OK"
    }
    ]



    [
    {
    "id": 1,
    "items": [
    {
    "count": 2,
    "id": 1
    }
    ]
    },
    {
    "id": 2,
    "items": [
    {
    "count": 2,
    "id": 1
    }
    ]
    }
    ]

    Примечания

    При написании решения на Java можно выбрать комплятор "Java 8 + network + json-simple". В этом случае вы сможете воспользоваться библиотекой json-simple для парсинга и сериализации JSON.
    Язык
    1

    ​

    осталось 100 попыток
    Посылок нет
    СправкаОбратная связьПользовательское соглашение
    © 2013–2021  ООО «Яндекс»

</div>

<div>
    Яндекс
    Контест
    Русский
    goro4@mail.ru

    Школа бэкенд-разработки 2021 (осень)
    7 сен 2021, 12:32:20
    старт:
    7 сен 2021, 12:26:54
    финиш:
    7 сен 2021, 18:26:54
    до финиша:
    05:52:12
    ...
    B. Восстановление шифра
    Ограничение времени 	1 секунда
    Ограничение памяти 	512Mb
    Ввод 	стандартный ввод или input.txt
    Вывод 	стандартный вывод или output.txt
    Специалисты информационной безопасности часто используют различные способы шифрования. К сожалению, размер зашифрованной информации получается больше первоначальной, поэтому ее легче повредить при передаче по сети. Помогите разработчикам восстановить зашифрованную информацию после передачи.

    Первоначально информация представляет собой набор C из n целых неотрицательных чисел c1,c2,c3,…,cn.

    При шифровании из набора образуется таблица T размера n⋅n:

    tij = ciANDcj, если i≠j [побитовое И]
    tii = −1.

    Необходимо по таблице T восстановить первоначальный набор C. Если подходящих наборов несколько - выведите любой из них.

    Формат ввода
    В первой строке дано целое неотрицательное число n(1≤n≤100)  — размер набора C и количество строк и столбцов в матрице T.

    Следующие n строк содержат по n целых чисел tij(0≤tij≤231−1,i≠j;tii=−1)  — элементы таблицы T.

    Гарантируется, что матрица T является симметричной (tij=tji) для всех i, j.

    Гарантируется, что существует хотя бы один набор C такой, что матрица T является его шифром.

    Формат вывода
    В единственной строке выведите набор C из n целых неотрицательных чисел такой, что tij = ciANDcj для всех i≠j. Если возможных наборов несколько - выведите любой, удовлетворяющий условиям задачи.
    Пример 1
    Ввод
    Вывод

    1
    -1



    0

    Пример 2
    Ввод
    Вывод

    3
    -1 18 0
    18 -1 0
    0 0 -1



    18 18 0

    Пример 3
    Ввод
    Вывод

    4
    -1 128 128 128
    128 -1 148 160
    128 148 -1 128
    128 160 128 -1



    128 180 148 160

    Язык
    1

    ​

    осталось 100 попыток
    Посылок нет
    СправкаОбратная связьПользовательское соглашение
    © 2013–2021  ООО «Яндекс»

</div>
<div>
    Яндекс
    Контест
    Русский
    goro4@mail.ru

    Школа бэкенд-разработки 2021 (осень)
    7 сен 2021, 12:52:47
    старт:
    7 сен 2021, 12:26:54
    финиш:
    7 сен 2021, 18:26:54
    до финиша:
    05:33:09
    ...
    C. Мониторинг логов
    Ограничение времени 	3 секунды
    Ограничение памяти 	512.0 Мб
    Ввод 	стандартный ввод или input.txt
    Вывод 	стандартный вывод или output.txt

    В команде разработки бэкенда одной известной компании задумались об автоматическом информировании об ошибках в системе. Для этого необходимо реализовать программу, анализирующую логи выбранной машины и определяющую первый момент времени, ставший критическим.

    Критическим называется такой момент времени KK, что на промежутке [K−t+1;K][K−t+1;K] приизошло суммарно ошибок больше либо равно ee.

    Ошибками являются все сообщения, имеющие статус ERROR.
    Формат ввода

    В первой строке записаны два целых числа tt и e(1≤t≤86400;1≤e≤200)e(1≤t≤86400;1≤e≤200) - размер промежутка времени для вычисления критического момента и минимально необходимое суммарное число ошибок на промежутке.

    Последующие строки описывают лог машины. Общее количество строк не превышает 3⋅1053⋅105. Каждая строка задаёт ровно одно сообщение в формате

    [yyyy-MM-dd hh:mm:ss] STATUS MESSAGE

    Дата и время сообщения принимают значения от 2020-01-01 00:00:00 до 2021-12-31 23:59:59 и находятся во временной зоне UTC(+0). Сообщения отсортированы в хронологическом порядке. Напоминаем, что 2020 - високосный год.

    Поле STATUS может принимать значения

    INFO
    WARNING
    ERROR

    Поле MESSAGE может быть любой последовательностью символов ASCII, за исключением разделителей строк, длины меньше 30 символов.
    Формат вывода

    Если не существует критического момента времени - выведите -1. Иначе выведите строку в формате yyyy-MM-dd hh:mm:ss — первый критический момент времени, когда количество ошибок за последние tt секунд стало не менее ee.
    Пример 1
    Ввод
    Вывод

    60 3
    [2020-03-16 16:15:25] INFO Disk size is 100 Gb
    [2020-03-16 16:15:25] ERROR Db failute
    [2020-03-16 16:15:25] ERROR Network failute
    [2020-03-16 16:16:29] ERROR Cant write varlog
    [2020-03-16 16:16:42] ERROR Unable to start process
    [2020-03-16 16:16:43] WARNING Disk size is too small
    [2020-03-16 16:16:43] ERROR Config not found
    [2020-03-16 16:16:53] ERROR Timeout detected



    2020-03-16 16:16:43

    Пример 2
    Ввод
    Вывод

    1 2
    [2020-03-16 23:59:59] ERROR Disk crash
    [2020-03-17 00:00:00] ERROR Network failute
    [2020-03-17 00:00:01] ERROR Cant write varlog



    -1

    Пример 3
    Ввод
    Вывод

    2 2
    [2020-03-16 16:15:25] INFO Disk size is 100 Gb
    [2020-03-16 23:59:59] ERROR Disk size is too sm
    [2020-03-17 00:00:00] ERROR Network failute dete
    [2020-03-17 00:00:01] ERROR Cant write varlogmysq



    2020-03-17 00:00:00

    Примечания

    В примере под номером 1 выбираются сообщения

    [2020-03-16 16:16:29] ERROR Cant write varlog
    [2020-03-16 16:16:42] ERROR Unable to start process
    [2020-03-16 16:16:43] ERROR Config not found

    В примере под номером 2 нет подходящих сообщений. Чтобы ответ был не -1, достаточно чтобы любые два сообщения пришли в одну и ту же секунду.

    В примере под номером 3 выбираются сообщения

    [2020-03-16 23:59:59] ERROR Disk size is too sm
    [2020-03-17 00:00:00] ERROR Network failute dete

    Язык
    1

    ​

    осталось 100 попыток
    Посылок нет
    СправкаОбратная связьПользовательское соглашение
    © 2013–2021  ООО «Яндекс»

</div>
<div>
    Яндекс
    Контест
    Русский
    goro4@mail.ru

    Школа бэкенд-разработки 2021 (осень)
    7 сен 2021, 16:49:27
    старт:
    7 сен 2021, 12:26:54
    финиш:
    7 сен 2021, 18:26:54
    до финиша:
    01:36:35
    ...
    D. Join между файлами
    Ограничение времени 	6 секунд
    Ограничение памяти 	128.0 Мб
    Ввод 	стандартный ввод или input.txt
    Вывод 	стандартный вывод или output.txt

    Во время проектирования распределенной системы планировалось использовать две различные базы данных.
    Разработчики не предусмотрели, что им может понадобится выполнять операцию сопоставления значений между таблицами этих баз
    данных. Помогите им придумать, как выполнить операцию inner join.

    База данных market и таблица market.shop представляет собой таблицу магазинов из двух колонок

    shop_id - идентификатор магазина
    shop_name - название магазина

    База данных billing и таблица billing.order представляет собой таблицу заказов из трех колонок

    order_id - идентификатор заказа
    shop_id - идентификатор магазина для, который выполнил заказ
    cost - общая стоимость товаров в заказе

    Необходимо получить новую таблицу в которой будут следующие колонки:

    order_id - номер заказа
    shop_name - название магазина
    shop_id - идентификатор магазина
    cost - общая стоимость товаров в заказе

    Формат ввода

    Для удобства базы данных представлены в виде файлов в формате csv, каждый файл отсортирован по возрастанию поля shop_id.

    Содержимое файлов, используемых в тестах условия, представлено в примечании.

    На вход программе подаются названия файлов в одной строке, разделенные пробелом, в которых содержатся таблицы,
    описанные ниже. Строка заканчивается переводом строки (символом '\n').

    market.shop.filename billing.order.filename

    Пример содержимого файла таблицы market.shop:

    shop_id,shop_name
    1,MyShop
    2,Pleer.ru
    ...

    Гарантируется, что все shop_id в таблице market.shop уникальны.

    Пример содержимого файла таблицы billing.order:

    order_id,shop_id,cost
    16423,1,23040
    242,2,1680000
    ...

    Гарантируется, что все order_id в таблице billing.order уникальны.

    Обозначим за NN, MM количество строк с данными в файлах market.shop.filename и billing.order.filename соответственно.

    Гарантируются следующие ограничения:

    0≤N,M≤1060≤N,M≤106.

    0≤0≤ shop_id, order_id, cost ≤1018≤1018

    1≤1≤ |shop_name| ≤30≤30, значения в колонке shop_name состоят из латинских букв, цифр и знаков подчеркивания.
    Формат вывода

    Таблица в виде

    order_id,shop_name,shop_id,cost
    16423,MyShop,1,23040
    242,Pleer.ru,2,1680000
    ...

    Пример 1
    Ввод
    Вывод

    market_1.csv billing_1.csv



    order_id,shop_name,   shop_id,cost
    1,       shop_name_1, 1,      100
    2,shop_name_2,2,200
    3,shop_name_3,3,300
    4,shop_name_4,4,400
    5,shop_name_5,5,500

    Пример 2
    Ввод
    Вывод

    market_1.csv billing_2.csv



    order_id,shop_name,shop_id,cost
    1,shop_name_1,1,100
    2,shop_name_2,2,200
    3,shop_name_2,2,200
    4,shop_name_2,2,200
    5,shop_name_5,5,500

    Пример 3
    Ввод
    Вывод

    market_2.csv billing_1.csv



    order_id,shop_name,shop_id,cost
    2,shop_name_2,2,200

    Пример 4
    Ввод
    Вывод

    market_2.csv billing_2.csv



    order_id,shop_name,shop_id,cost
    2,shop_name_2,2,200
    3,shop_name_2,2,200
    4,shop_name_2,2,200

    Примечания

    market_1.csv

    shop_id,shop_name
    1,shop_name_1
    2,shop_name_2
    3,shop_name_3
    4,shop_name_4
    5,shop_name_5

    market_2.csv

    shop_id,shop_name
    2,shop_name_2

    billing_1.csv

    order_id,shop_id,cost
    1,1,100
    2,2,200
    3,3,300
    4,4,400
    5,5,500

    billing_2.csv

    order_id,shop_id,cost
    1,1,100
    2,2,200
    3,2,200
    4,2,200
    5,5,500

    Язык
    1

    ​

    осталось 100 попыток
    Посылок нет
    СправкаОбратная связьПользовательское соглашение
    © 2013–2021  ООО «Яндекс»

</div>
<div>
    Яндекс
    Контест
    Русский
    goro4@mail.ru

    Школа бэкенд-разработки 2021 (осень)
    7 сен 2021, 16:49:28
    старт:
    7 сен 2021, 12:26:54
    финиш:
    7 сен 2021, 18:26:54
    до финиша:
    00:38:16
    ...
    E. Статистика
    Ограничение времени 	12 секунд
    Ограничение памяти 	512.0 Мб
    Ввод 	стандартный ввод или input.txt
    Вывод 	стандартный вывод или output.txt

    Одной команде Яндекс Маркета предстояло решить ответственную задачу.
    На основе статистических данных необходимо определить самые продаваемые товары за последние несколько месяцев.


    Описание таблиц базы данных

    Статистика представляет собой таблицу statistic в базе данных в которой содержатся колонки:

    date - день, за который формировалась статистика - тип date
    name - название товара - тип text
    description - идентификатор описания товара - тип text
    category_id - идентификатор категории товара - тип integer
    brand_id - идентификатор бренда товара - тип integer
    shows - число показов на витрине Маркета - тип integer
    clicks - число переходов по ссылке на конкретный товар - тип integer
    orders - число успешно доставленных товаров - тип integer
    gmv - сумма денежных средств, вырученная с продажи определенного товара - тип integer

    Что такое GMV?

    Пример строки таблицы statistic:
    date 	name 	description 	category_id 	brand_id 	shows 	clicks 	orders 	gmv
    2021-05-22 	Телевизор HARPER 32R490T 32 (2020) 	739589 	90639 	11169208 	1083 	4 	2 	12796

    Из строки можно понять, что за 22-ое мая 2021 года товар с названием "Телевизор HARPER 32R490T 32 (2020)" был показан покупателям 1083 раза, 4 раза на страницу товара заходили по клику, и 2 раза этот товар был успешно продан на общую сумму 12796 рублей.

    Также известно, что он принадлежит бренду с идентификатором 11169208 и находится в категории по идентификатору 90639.

    Для получения названий брендов и категорий используется две таблицы brands и categories, каждая из которых содержит колонки

    id - идентификатор - тип integer
    name - название категории/бренда - тип text

    Таблица brands
    id 	name
    90555 	Philips

    Таблица categories
    id 	name
    14694813 	Наушники

    Гарантируется, что таблицы brands и categories содержат все необходимые идентификаторы.


    Критерии получения данных

    Необходимо вывести первые 100 строк, описывающие динамику продаж товаров, которые удовлетворяют необходимым требованиям.

    Период исследуемой статистики - [2021-04-01, 2021-07-31] , обе границы включительно.
    Для более объективного анализа необходимо получить общую сумму продаж каждого товара за каждый месяц исследуемой статистики - это Временной ряд. Месяц определяется первым днём этого месяца. Для даты 2021-04-15 месяцем является дата 2021-04-01.
    Необходимо исключить некорректные данные. Данные некорректны, если за один день число показов меньше, чем число кликов, или число кликов меньше, чем число успешно выполненных заказов.
    Часто в статистике фигурируют товары, которые продаются намного дороже других. Поэтому требуется исключить из обрабатываемых данных категории "Варочные панели" и "Садовые измельчители", а также бренды "Apple" и "Samsung".

    Результат запроса необходимо отсортировать по двум параметрам
    по дате агрегации(первому числу месяца) по возрастанию;
    по gmv за период агрегации по убыванию.

    Для соблюдения консистентности, результат запроса необходимо сгруппировать в том числе по описанию, названию товара, названию бренда и названию категории.

    Результат запроса должен содержать колонки

    monthDate - месяц, за который была выполнена агрегация
    description - идентификатор описания товара
    item_name - название товара
    category_name - название категории
    brand_name - название бренда
    sum_shows - суммарное количество показов за период агрегации
    sum_clicks - суммарное количество кликов за период агрегации
    sum_orders - суммарное количество успешно выполненных заказов за период агрегации
    sum_gmv - суммарная выручка за период агрегации


    Пример

    Исходная таблица statistic
    Номер строки 	date 	name 	description 	category_id 	brand_id 	shows 	clicks 	orders 	gmv
    1 	2021-03-23 	Ноутбук Lenovo ThinkPad 	784011 	91013 	152981 	423 	233 	33 	324434
    2 	2021-04-14 	Ноутбук Lenovo ThinkPad 	784011 	91013 	152981 	622 	524 	44 	232413
    3 	2021-04-14 	Ноутбук Lenovo ThinkPad 	784011 	91013 	152981 	562 	233 	45 	232413
    4 	2021-06-14 	Ноутбук Lenovo ThinkPad 	784011 	91013 	152981 	226 	211 	23 	644464
    5 	2021-06-14 	Ноутбук MGN73RU/A 	68686 	91013 	439977 	456 	311 	193 	1025446
    6 	2021-06-14 	Ноутбук Lenovo ThinkPad 	784011 	91013 	152981 	175 	179 	43 	334434
    7 	2021-08-02 	Ноутбук Lenovo ThinkPad 	784011 	91013 	152981 	135 	136 	23 	345434
    8 	2021-07-15 	Ноутбук Lenovo ThinkPad 	784011 	91013 	152981 	165 	43 	13 	343443
    9 	2021-05-14 	Ноутбук APPLE MacBook Pro 13 	730972 	91013 	153043 	143 	34 	23 	3434
    10 	2021-07-17 	Ноутбук APPLE MacBook Air 13 	793137 	91013 	153043 	3833 	453 	43 	234333
    11 	2021-04-14 	Ноутбук APPLE MacBook Air 13 	793137 	91013 	153043 	394 	233 	32 	2342443
    12 	2021-08-14 	Варочная панель Maunfeld 	702254 	237418 	7085802 	16 	13 	12 	23432334
    13 	2021-04-20 	Варочная панель ПВИ 4000 GEFEST 	708146 	237418 	152771 	11 	11 	10 	2342343

    Результат запроса
    monthDate 	description 	name 	category_name 	brand_name 	sum_shows 	sum_clicks 	sum_orders 	sum_gmv
    2021-04-01 	784011 	Ноутбук Lenovo ThinkPad 	Ноутбуки 	Lenovo 	1184 	757 	89 	464826
    2021-06-01 	68686 	Ноутбук MGN73RU/A 	Ноутбуки 	Midea 	456 	311 	193 	1025446
    2021-06-01 	784011 	Ноутбук Lenovo ThinkPad 	Ноутбуки 	Lenovo 	226 	211 	23 	644464
    2021-07-01 	784011 	Ноутбук Lenovo ThinkPad 	Ноутбуки 	Lenovo 	165 	43 	13 	343443
    Формат ввода

    В данной задаче на вход не подаётся никаких данных.
    Формат вывода

    В поле отправки необходимо вставить корректный SQL-запрос для базы данных SQLite, выполняющий поставленную задачу.
    В качестве компилятора необходимо выбрать "SQLite 3.31.1". Запрос будет выполнен на реальной базе данных,
    после чего результат будет проверен на корректность и соответствие поставленной задаче.

    Вердикт RE в данной задаче может означать следующие проблемы:

    невалидный с точки зрения SQLite запрос (любая ошибка, которая не позволяет базе данных выполнить запрос).
    Сюда относятся ошибки в синтаксических конструкциях, неверные имена таблиц, колонок и т.д.
    слишком большой размер ответа (превышает настройки системы).

    Вердикт WA означает, что ваше решение является синтаксически верным на языке SQLite
    (язык способен его запустить и вычислить результат), но результат запроса не совпал с ожидаемым.
    В том числе слишком большой вывод, но умещающийся в ограничения системы, будет помечен вердиктом WA, а не RE.

    Гарантируется, что ответ в данной задаче определен однозначно при выполнении всех требований условия.
    Примечания

    Разберем предложенный пример

    Строки номер 1 и номер 7 исключаются из результата, так как не попадают в заданный интервал [2021-04-01, 2021-07-31]
    Строки под номерами 9,10, 11 исключаются, так как принадлежат бренду Apple
    Строки с номерами 12 и 13 исключаются, так как входят в категорию Варочных панелей
    Строка 6 исключается, так как содержит некорректные данные (число кликов больше чем число показов)
    Остаются строки под номерами 2,3,4,5,8
    Строки 2 и 3 агрегируются, так как относятся к одному товару и попадают в общий период агрегации - месяц апрель, сумма GMV равна 232413 + 232413 = 464826
    Строки 4 и 5 попадают в период агрегации - июнь
    Строка 8 попадает в период агрегации - июль

    Язык
    1

    ​

    осталось 100 попыток
    Посылок нет
    СправкаОбратная связьПользовательское соглашение
    © 2013–2021  ООО «Яндекс»

</div>
<div>

    F. Кэширование запросов
    Ограничение времени 	3 секунды
    Ограничение памяти 	512Mb
    Ввод 	стандартный ввод или input.txt
    Вывод 	стандартный вывод или output.txt
    Сервисы Яндекса постоянно находятся под нагрузкой миллионов пользователей.
    Для эффективности их работы часть запросов кэшируется с помощью определенных алгоритмов.

    Вам предлагается смоделировать алгоритм кэширования,
    при котором в памяти хранится информация о m наиболее поздних по времени вызова запросах.
    Важной деталью является тот факт, что порядок получения кэшом информации о запросах
    необязательно совпадает с порядком их вызова.

    Для работы с кэшем есть 3 типа операций:

    PUT  — положить информацию о запросе в кэш (если запроса нет в кэше).
    UPDATE  — обновить информацию о запросе (если запрос уже есть в кэше).
    DELETE  — удалить информацию о запросе из кэша, если необходимо освободить место.

    Необходимо обработать список запросов и вывести список совершенных с кэшом операций,
    чтобы в любой момент соблюдались следующие условия:

    Хранимые в кэше запросы являются наиболее поздними по времени вызова среди уже обработанных.
    Количество запросов в кэше не превосходит m.
    Для каждого идентификатора запроса в кэше хранится самая поздняя по времени вызова информация.
    Операция PUT применяется только к запросам, которых нет в кэше на момент совершения операции,
    а UPDATE - только к уже находящимся в кэше.

    Формат ввода
    В первой строке заданы два целых числа n и m(1≤n,m≤200000)  — количество запросов и максимальный размер кэша.

    Каждая из следующих n строк содержит запрос в формате idtime(1≤∣∣id∣∣≤10;1≤time≤1018)  — идентификатор и время вызова запроса. Идентификатор id состоит из строчных латинских букв.

    Гарантируется, что все запросы вызывались в различные моменты времени (timei≠timej для i≠j).

    Формат вывода
    Необходимо вывести список совершенных с кэшом операций в формате indexoperationid, где:

    index(1≤index≤n)  — номер запроса, при обработке которого были совершена операция;
    operation  — это одна из строк PUT, UPDATE, DELETE.

    Выведенные операции должны удовлетворять следующим условиям:

    Хранимые в кэше запросы являются наиболее поздними по времени вызова среди уже обработанных.
    Количество запросов в кэше не превосходит m.
    Для каждого идентификатора запроса в кэше хранится самая поздняя по времени вызова информация.
    Операция PUT применяется только к запросам, которых нет в кэше на момент совершения операции,
    а UPDATE - только к уже находящимся в кэше.

    Пример 1
    Ввод
    Вывод

    6 3
    status 1
    history 2
    status 3
    price 4
    name 5
    card 6



    1 PUT status
    2 PUT history
    3 UPDATE status
    4 PUT price
    5 DELETE history
    5 PUT name
    6 DELETE status
    6 PUT card

    Пример 2
    Ввод
    Вывод

    5 2
    status 4
    history 2
    history 10
    price 7
    status 3



    1 PUT status
    2 PUT history
    3 UPDATE history
    4 DELETE status
    4 PUT price

    Примечания
    Рассмотрим первый тест из условия.

    На момент обработки третьей строки status 3 в кэше уже лежит запись о запросе status,
    поэтому производится операция UPDATE, а не PUT.
    Обратите внимание, что после данной операции в кэше лежит 2 записи,
    а не 3: (status 3; history 2).

    При обработке пятой строки name 5 из кэша необходимо удалить самую старую запись по времени вызова - history 2.
    В итоге после обработки пятой строки в кэше будут лежать записи (status 3; price 4; name 5).

    Во втором тесте важно отметить два факта:

    - запросы даются не в порядке времени вызова.

    - последняя строка status 3 никак не изменяет кэш, в котором на тот момент лежат записи (history 10; price 7),
    так как время запроса 3 ниже, чем оба присутствующих в кэше времён.

    Язык
    1

    ​

    осталось 100 попыток

    Посылок нет
    СправкаОбратная связьПользовательское соглашение
    © 2013–2021  ООО «Яндекс»

</div>
</body>
</html>