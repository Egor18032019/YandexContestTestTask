"# YandexContestTestTask" 
Участие в Яндекс-Контекст.
Не смог пройти тесты :(.
Где ошибка не знаю.
1 Задание которое решал:
C. Мониторинг логов
    Ограничение времени 	3 секунды
    Ограничение памяти 	512.0 Мб
    Ввод 	стандартный ввод или input.txt
    Вывод 	стандартный вывод или output.txt

    В команде разработки бэкенда одной известной компании задумались об автоматическом информировании об ошибках в системе. Для этого необходимо реализовать программу, анализирующую логи выбранной машины и определяющую первый момент времени, ставший критическим.

    Критическим называется такой момент времени KK, что на промежутке [K−t+1;K][K−t+1;K] приизошло суммарно ошибок больше либо равно ee.

    Ошибками являются все сообщения, имеющие статус ERROR.
    Формат ввода

    В первой строке записаны два целых числа tt и e(1≤t≤86400;1≤e≤200)e(1≤t≤86400;1≤e≤200) - размер промежутка времени для вычисления критического момента и минимально необходимое суммарное число ошибок на промежутке.

    Последующие строки описывают лог машины. Общее количество строк не превышает 3⋅1053⋅105. Каждая строка задаёт ровно одно сообщение в формате

    [yyyy-MM-dd hh:mm:ss] STATUS MESSAGE

    Дата и время сообщения принимают значения от 2020-01-01 00:00:00 до 2021-12-31 23:59:59 и находятся во временной зоне UTC(+0). Сообщения отсортированы в хронологическом порядке. Напоминаем, что 2020 - високосный год.

    Поле STATUS может принимать значения

    INFO
    WARNING
    ERROR

    Поле MESSAGE может быть любой последовательностью символов ASCII, за исключением разделителей строк, длины меньше 30 символов.
    Формат вывода

    Если не существует критического момента времени - выведите -1. Иначе выведите строку в формате yyyy-MM-dd hh:mm:ss — первый критический момент времени, когда количество ошибок за последние tt секунд стало не менее ee.
    Пример 1
    Ввод
    Вывод

    60 3
    [2020-03-16 16:15:25] INFO Disk size is 100 Gb
    [2020-03-16 16:15:25] ERROR Db failute
    [2020-03-16 16:15:25] ERROR Network failute
    [2020-03-16 16:16:29] ERROR Cant write varlog
    [2020-03-16 16:16:42] ERROR Unable to start process
    [2020-03-16 16:16:43] WARNING Disk size is too small
    [2020-03-16 16:16:43] ERROR Config not found
    [2020-03-16 16:16:53] ERROR Timeout detected



    2020-03-16 16:16:43

    Пример 2
    Ввод
    Вывод

    1 2
    [2020-03-16 23:59:59] ERROR Disk crash
    [2020-03-17 00:00:00] ERROR Network failute
    [2020-03-17 00:00:01] ERROR Cant write varlog



    -1

    Пример 3
    Ввод
    Вывод

    2 2
    [2020-03-16 16:15:25] INFO Disk size is 100 Gb
    [2020-03-16 23:59:59] ERROR Disk size is too sm
    [2020-03-17 00:00:00] ERROR Network failute dete
    [2020-03-17 00:00:01] ERROR Cant write varlogmysq



    2020-03-17 00:00:00

    Примечания

    В примере под номером 1 выбираются сообщения

    [2020-03-16 16:16:29] ERROR Cant write varlog
    [2020-03-16 16:16:42] ERROR Unable to start process
    [2020-03-16 16:16:43] ERROR Config not found

    В примере под номером 2 нет подходящих сообщений. Чтобы ответ был не -1, достаточно чтобы любые два сообщения пришли в одну и ту же секунду.

    В примере под номером 3 выбираются сообщения

    [2020-03-16 23:59:59] ERROR Disk size is too sm
    [2020-03-17 00:00:00] ERROR Network failute dete

2.Задание которое решал:
  F. Кэширование запросов
    Ограничение времени 	3 секунды
    Ограничение памяти 	512Mb
    Ввод 	стандартный ввод или input.txt
    Вывод 	стандартный вывод или output.txt
    Сервисы Яндекса постоянно находятся под нагрузкой миллионов пользователей.
    Для эффективности их работы часть запросов кэшируется с помощью определенных алгоритмов.

    Вам предлагается смоделировать алгоритм кэширования,
    при котором в памяти хранится информация о m наиболее поздних по времени вызова запросах.
    Важной деталью является тот факт, что порядок получения кэшом информации о запросах
    необязательно совпадает с порядком их вызова.

    Для работы с кэшем есть 3 типа операций:

    PUT  — положить информацию о запросе в кэш (если запроса нет в кэше).
    UPDATE  — обновить информацию о запросе (если запрос уже есть в кэше).
    DELETE  — удалить информацию о запросе из кэша, если необходимо освободить место.

    Необходимо обработать список запросов и вывести список совершенных с кэшом операций,
    чтобы в любой момент соблюдались следующие условия:

    Хранимые в кэше запросы являются наиболее поздними по времени вызова среди уже обработанных.
    Количество запросов в кэше не превосходит m.
    Для каждого идентификатора запроса в кэше хранится самая поздняя по времени вызова информация.
    Операция PUT применяется только к запросам, которых нет в кэше на момент совершения операции,
    а UPDATE - только к уже находящимся в кэше.

    Формат ввода
    В первой строке заданы два целых числа n и m(1≤n,m≤200000)
    — количество запросов и максимальный размер кэша.

    Каждая из следующих n строк содержит запрос в формате idtime(1≤∣∣id∣∣≤10;1≤time≤1018)  — идентификатор и время вызова запроса. Идентификатор id состоит из строчных латинских букв.

    Гарантируется, что все запросы вызывались в различные моменты времени (timei≠timej для i≠j).

    Формат вывода
    Необходимо вывести список совершенных с кэшом операций в формате indexoperationid, где:

    index(1≤index≤n)  — номер запроса, при обработке которого были совершена операция;
    operation  — это одна из строк PUT, UPDATE, DELETE.

    Выведенные операции должны удовлетворять следующим условиям:

    Хранимые в кэше запросы являются наиболее поздними по времени вызова среди уже обработанных.
    Количество запросов в кэше не превосходит m.
    Для каждого идентификатора запроса в кэше хранится самая поздняя по времени вызова информация.
    Операция PUT применяется только к запросам, которых нет в кэше на момент совершения операции,
    а UPDATE - только к уже находящимся в кэше.

    Пример 1
    Ввод
    Вывод

    6 3
    status 1
    history 2
    status 3
    price 4
    name 5
    card 6



    1 PUT status
    2 PUT history
    3 UPDATE status
    4 PUT price
    5 DELETE history
    5 PUT name
    6 DELETE status
    6 PUT card

    Пример 2
    Ввод
    Вывод

    5 2
    status 4
    history 2
    history 10
    price 7
    status 3



    1 PUT status
    2 PUT history
    3 UPDATE history
    4 DELETE status
    4 PUT price

    Примечания
    Рассмотрим первый тест из условия.

    На момент обработки третьей строки status 3 в кэше уже лежит запись о запросе status,
    поэтому производится операция UPDATE, а не PUT.
    Обратите внимание, что после данной операции в кэше лежит 2 записи,
    а не 3: (status 3; history 2).

    При обработке пятой строки name 5 из кэша необходимо удалить самую старую запись по времени вызова - history 2.
    В итоге после обработки пятой строки в кэше будут лежать записи (status 3; price 4; name 5).

    Во втором тесте важно отметить два факта:

    - запросы даются не в порядке времени вызова.

    - последняя строка status 3 никак не изменяет кэш, в котором на тот момент лежат записи (history 10; price 7),
    так как время запроса 3 ниже, чем оба присутствующих в кэше времён.

    Язык
    1
Выложил на гитхаб уже после Яндекс-контест."# tryYandexContest" 
